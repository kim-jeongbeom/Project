기본 개념
복잡하거나 커스텀한 쿼리가 필요한 경우, @Query 어노테이션을 사용해 JPQL(혹은 native SQL)을 직접 작성할 수 있다.

기본 사용법
public interface MemberRepository extends JpaRepository<Member, Long> {
    @Query("SELECT m FROM Member m WHERE m.username = :username AND m.age > :age")
    List<Member> findUser(@Param("username") String username, @Param("age") int age);

    @Query(value = "SELECT * FROM member WHERE username = :username", nativeQuery = true)
    List<Member> findByNativeQuery(@Param("username") String username);
}

• @Param을 이용해 파라미터를 바인딩한다.
• nativeQuery = true를 사용하면 SQL 문법 그대로 쓸 수 있다.
장점
1. 객체 지향적인 쿼리로 DB 테이블 조인이 아닌 java에서 엔티티관계 및 상속 개념으로 봐야한다.
2. 반환 유형을 지정할 수 있다.
3. 특정 유형의 DB(Mysql, Oracle)에 연결된 것이 아니기에 데이터베이스 변경 시에도 유지, 보수 부분에서 유연하며 쿼리를 다시 작성할 필요가 없다.
4. 코드 실행 단계가 아닌 코드를 작성하는 시점에서 빠르게 오류를 발견할 수 있다.
단점
1. 모든 SQL 기능을 지원하지 않아 쿼리 작성에 유연하지 않다.
2. 여러 조인이나 복잡한 쿼리를 작성해야 할때 어렵다.
3. 매핑하여 사용하는만큼 DB에 직접적으로 쿼리를 실행하는 NativeQuery보다 속도적인 부분에서 차이가 있다.
